{"version":3,"file":"bundle.js","sources":["../../node_modules/svelte/internal/index.mjs","../../node_modules/dexie/dist/modern/dexie.mjs","../../src/db.js","../../src/App.svelte","../../src/main.js"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        while (flushidx < dirty_components.length) {\n            const component = dirty_components[flushidx];\n            flushidx++;\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.3' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.0, Thu Nov 18 2021\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj)\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n        }\n        catch (ex) {\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.0';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            trans.create();\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    return new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    addEventListener('storage', (ev) => {\n        if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n            const data = JSON.parse(ev.newValue);\n            if (data)\n                propagateLocally(data.changedParts);\n        }\n    });\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n//# sourceMappingURL=dexie.mjs.map\n","import Dexie from 'dexie';\n\nexport const db = new Dexie('endsong');\n\ndb.version(1).stores({\n  plays: \"++id,ts,username,platform,ms_played,conn_country,ip_addr_decrypted,user_agent_decrypted,master_metadata_track_name, master_metadata_album_artist_name,master_metadata_album_album_name,spotify_track_uri,episode_name,episode_show_name,spotify_episode_uri,reason_start,reason_end,shuffle,skipped,offline,offline_timestamp,incognito_mode\",\n});\n","<script>\n\timport { liveQuery } from \"dexie\";\n\timport { db } from \"./db\";\n\n\tlet count = liveQuery(() => db.plays.count());\n\n\tlet files;\n\tlet query;\n\tlet queryResult;\n\n\tasync function getJSON(blob) {\n\t\tconst text = await blob.text();\n\t\treturn JSON.parse(text);\n\t}\n\n\tasync function loadFiles() {\n\t\tfor (const file of files) {\n\t\t\tconst plays = await getJSON(file);\n\t\t\tfor (let play of plays) {\n\t\t\t\tif (play.ts) {\n\t\t\t\t\tplay.ts = play.ts.replace(\" UTC\", \"Z\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tawait db.plays.bulkAdd(plays);\n\t\t}\n\t}\n\n\tasync function runQuery() {\n\t\ttry {\n\t\t\treturn eval(query);\n\t\t} catch (error) {\n\t\t\treturn error;\n\t\t}\n\t}\n</script>\n\n<div class=\"mx-auto max-w-lg mt-4 bg-gray-100 dark:bg-gray-800 rounded-lg\">\n\t<div class=\"align-middle mx-auto\">\n\t\t<input type=\"file\" accept=\".json\" multiple bind:files>\n\n\t\t{#if files && files[0]}\n\t\t{#await loadFiles()}\n\t\t\t<p>\n\t\t\t\tLoading files..\n\t\t\t</p>\n\t\t{:then text}\n\t\t\t<p>\n\t\t\t\t{text}\n\t\t\t</p>\n\t\t{:catch error}\n\t\t\t<p style=\"color: red\">{error.message}</p>\n\t\t{/await}\n\t\t{/if}\n\n\t\t{$count == null ? \"\" : $count + \" plays loaded\"}\n\t</div>\n\n\t<textarea bind:value={query} on:input={() => queryResult = runQuery()}></textarea>\n\n\t{#if query}\n\t{#await queryResult}\n\t\t<p>\n\t\t\tEvaluating..\n\t\t</p>\n\t{:then text}\n\t\t<p>\n\t\t\t{text}\n\t\t</p>\n\t{:catch error}\n\t\t<p style=\"color: red\">{error.message}</p>\n\t{/await}\n\t{/if}\n</div>\n\n<style global lang=\"postcss\">\n\t@tailwind base;\n\t@tailwind components;\n\t@tailwind utilities;\n\n\t:global(body) {\n\t\t@apply bg-blue-500;\n\t}\n</style>\n","import App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body\n});\n\nexport default app;"],"names":["noop","is_promise","value","then","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","is_empty","obj","keys","length","subscribe","store","callbacks","unsub","unsubscribe","component_subscribe","component","callback","$$","on_destroy","push","append","target","node","appendChild","insert","anchor","insertBefore","detach","parentNode","removeChild","element","name","document","createElement","text","data","createTextNode","space","empty","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","removeAttribute","getAttribute","setAttribute","children","Array","from","childNodes","set_data","wholeText","set_input_value","input","set_style","key","important","style","setProperty","current_component","set_current_component","get_current_component","Error","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","schedule_update","flush","add_render_callback","seen_callbacks","Set","flushidx","saved_component","update","pop","i","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","outros","group_outros","r","c","check_outros","transition_in","block","local","delete","transition_out","o","d","handle_promise","promise","info","token","type","index","resolved","child_ctx","undefined","slice","current","needs_flush","blocks","m","mount","error","catch","hasCatch","pending","update_await_block_branch","mount_component","customElement","on_mount","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","fill","init","instance","create_fragment","not_equal","props","append_styles","parent_component","bound","on_disconnect","context","Map","skip_bound","root","ready","ret","rest","hydrate","nodes","l","intro","SvelteComponent","$destroy","this","$on","indexOf","splice","$set","$$props","$$set","_global","globalThis","self","window","global","isArray","extend","extension","getProto","getPrototypeOf","_hasOwn","hasOwnProperty","hasOwn","prop","call","proto","Reflect","ownKeys","setProp","defineProperty","functionOrGetSet","get","set","configurable","writable","derive","Child","Parent","prototype","bind","getOwnPropertyDescriptor","getPropertyDescriptor","_slice","args","start","end","override","origFunc","overridedFactory","assert","asap$1","setImmediate","setTimeout","arrayToObject","array","extractor","reduce","result","item","nameAndValue","tryCatch","onerror","apply","ex","getByKeyPath","keyPath","rv","val","period","innerObj","substr","setByKeyPath","isFrozen","currentKeyPath","remainingKeyPath","isNaN","parseInt","delByKeyPath","kp","shallowClone","concat","flatten","intrinsicTypeNames","split","num","t","intrinsicTypes","x","circularRefs","deepClone","any","WeakMap","innerDeepClone","constructor","toString","toStringTag","iteratorSymbol","Symbol","iterator","getIteratorOf","NO_CHAR_ARRAY","getArrayOf","arrayLike","it","arguments","next","done","isAsyncFunction","debug","location","test","href","setDebug","libraryFilter","NEEDS_THROW_FOR_STACK","stack","getErrorWithStack","e","prettyStack","exception","numIgnoredFrames","message","frame","join","dexieErrorNames","idbDomErrorNames","errorList","defaultTexts","VersionChanged","DatabaseClosed","Abort","TransactionInactive","MissingAPI","DexieError","msg","_e","getMultiErrorMessage","failures","v","s","ModifyError","successCount","failedKeys","BulkError","pos","failuresByPos","_stack","errnames","BaseException","exceptions","fullName","msgOrInner","inner","Syntax","SyntaxError","Type","TypeError","Range","RangeError","exceptionMap","mapError","domError","fullNameExceptions","nop","mirror","pureFunctionChain","f1","f2","callBoth","on1","on2","hookCreatingChain","res","onsuccess","res2","hookDeletingChain","hookUpdatingChain","modifications","reverseStoppableEventChain","promisableChain","thiz","INTERNAL","LONG_STACKS_CLIP_LIMIT","MAX_LONG_STACKS","ZONE_ECHO_LIMIT","resolvedNativePromise","nativePromiseProto","resolvedGlobalPromise","globalP","crypto","subtle","nativeP","digest","Uint8Array","nativePromiseThen","NativePromise","patchGlobalPromise","stack_being_generated","schedulePhysicalTick","physicalTick","MutationObserver","hiddenDiv","observe","attributes","asap","microtickQueue","needsNewPhysicalTick","isOutsideMicroTick","unhandledErrors","rejectingErrors","currentFulfiller","rejectionMapper","globalPSD","id","ref","unhandleds","onunhandled","globalError","pgp","env","finalize","uh","PSD","numScheduledCalls","tickFinalizers","DexiePromise","_listeners","onuncatched","_lib","psd","_PSD","_stackHolder","_prev","_numPrev","_state","_value","handleRejection","executePromiseTask","thenProp","microTaskId","totalEchoes","onFulfilled","onRejected","possibleAwait","cleanup","decrementExpectedAwaits","reject","propagateToListener","Listener","nativeAwaitCompatibleWrap","linkToPreviousPromise","zone","shouldExecuteTick","beginMicroTickScope","_then","propagateAllListeners","endMicroTickScope","reason","_promise","origProp","addPossiblyUnhandledError","listeners","len","finalizePhysicalTick","listener","cb","callListener","markErrorAsHandled","getStack","stacks","limit","errorName","failure","prev","numPrev","wasRootExec","unhandledErrs","finalizers","run_at_end_of_this_or_next_physical_tick","finalizer","some","PromiseReject","wrap","errorCatcher","outerScope","switchToZone","err","finally","onFinally","timeout","ms","Infinity","handle","Timeout","clearTimeout","snapShot","all","values","onPossibleParallellAsync","remaining","race","newPSD","newScope","usePSD","scheduler","follow","zoneProps","allSettled","possiblePromises","results","status","AggregateError","task","awaits","echoes","taskCounter","zoneStack","zoneEchoes","zone_id_counter","a1","a2","parent","globalEnv","PromiseProp","nthen","getPatchedPromiseThen","gthen","incrementExpectedAwaits","possiblePromise","rejection","zoneEnterEcho","targetZone","zoneLeaveEcho","bEnteringZone","currentZone","enqueueNativeMicroTask","GlobalPromise","targetEnv","a3","job","outerZone","origThen","onResolved","UNHANDLEDREJECTION","eventData","createEvent","initEvent","CustomEvent","detail","dispatchEvent","PromiseRejectionEvent","onunhandledrejection","_","defaultPrevented","console","warn","tempTransaction","db","mode","storeNames","idbdb","openComplete","letThrough","_vip","trans","_createTransaction","_dbSchema","_completion","dbOpenError","isBeingOpened","_options","autoOpen","open","dbReadyPromise","DEXIE_VERSION","maxString","String","fromCharCode","minKey","INVALID_KEY_ARGUMENT","STRING_EXPECTED","connections","isIEOrEdge","navigator","userAgent","hasIEDeleteObjectStoreBug","hangsOnDeleteLargeKeyRange","dexieStackFrameFilter","DBNAMES_DB","READONLY","READWRITE","combine","filter1","filter2","AnyRange","lower","lowerOpen","upper","upperOpen","workaroundForUndefinedPrimKey","Table","_trans","writeLocked","_tx","tableName","checkTableInTransaction","schema","NotFound","idbtrans","transless","keyOrCrit","where","first","core","hook","reading","fire","indexOrCrit","WhereClause","keyPaths","equals","compoundIndex","indexes","primKey","ix","compound","every","_maxKey","JSON","stringify","idxByName","idb","_deps","indexedDB","cmp","idx","filterFunction","prevIndex","prevFilterFn","multi","toCollection","and","count","thenShortcut","offset","numRows","each","toArray","Collection","orderBy","reverse","mapToClass","mappedClass","readHook","defineClass","content","auto","objToAdd","mutate","numFailures","lastResult","keyOrObject","modify","InvalidArgument","_a","put","range","bulkGet","getMany","bulkAdd","objects","keysOrOptions","wantResults","allKeys","numObjects","objectsToAdd","bulkPut","objectsToPut","bulkDelete","numKeys","Events","evs","eventName","subscriber","addEventType","chainFunction","defaultFunction","addConfiguredEvents","subscribers","cfg","makeClassConstructor","createTableConstructor","tableSchema","_allTables","creating","updating","deleting","isPlainKeyRange","ignoreLimitFilter","algorithm","or","justLimit","replayFilter","addFilter","addReplayFilter","factory","isLimitFilter","curr","addMatchFilter","isMatch","getIndexOrStore","coreSchema","isPrimKey","primaryKey","getIndexByKeyPath","Schema","openCursor","coreTable","keysOnly","dir","unique","query","iter","coreTrans","union","cursor","advance","stop","fail","_iterate","iterate","valueMapper","cursorPromise","wrappedFn","continue","advancer","ta","tb","NaN","compareUint8Arrays","getUint8Array","compareArrays","al","bl","ArrayBuffer","isView","tsTag","buffer","byteOffset","byteLength","_read","_ctx","table","_write","_addAlgorithm","clone","raw","Math","min","sortBy","parts","lastPart","lastIndex","getval","order","sorter","aVal","bVal","sort","offsetLeft","rowsLeft","until","bIncludeStopEntry","last","indexName","_ondirectionchange","desc","eachKey","eachUniqueKey","eachPrimaryKey","primaryKeys","uniqueKeys","firstKey","lastKey","distinct","strKey","found","changes","modifyer","anythingModified","outbound","extractKey","modifyChunkSize","totalFailures","applyMutateResult","expectedCount","nextChunk","cache","addValues","putValues","putKeys","deleteKeys","origValue","criteria","deleteCallback","changeSpec","coreRange","createCollectionConstructor","whereClause","keyRangeGenerator","keyRange","whereCtx","readingHook","simpleCompare","simpleCompareReverse","collectionOrWhereClause","T","collection","emptyCollection","rangeEqual","upperFactory","toUpperCase","toLowerCase","lowerFactory","nextCasing","lowerKey","upperNeedle","lowerNeedle","llp","lwrKeyChar","addIgnoreCaseAlgorithm","match","needles","suffix","compare","upperNeedles","lowerNeedles","direction","nextKeySuffix","needlesLen","initDirection","needleBounds","needle","nb","createRange","firstPossibleNeedle","lowestPossibleCasing","casing","between","includeLower","includeUpper","_cmp","above","aboveOrEqual","below","belowOrEqual","startsWith","str","startsWithIgnoreCase","equalsIgnoreCase","anyOfIgnoreCase","startsWithAnyOfIgnoreCase","n","anyOf","_ascending","_descending","notEqual","inAnyRange","includeLowers","includeUppers","noneOf","ranges","ascending","descending","_min","max","_max","sortDirection","rangeSorter","newRange","rangePos","keyIsBeyondCurrentEntry","keyIsBeforeCurrentEntry","checkKey","keyWithinCurrentRange","startsWithAnyOf","createWhereClauseConstructor","orCollection","_IDBKeyRange","IDBKeyRange","eventRejectHandler","preventDefault","stopPropagation","DEXIE_STORAGE_MUTATED_EVENT_NAME","STORAGE_MUTATED_DOM_EVENT_NAME","globalEvents","Transaction","_lock","_reculock","lockOwnerFor","_unlock","_blockedFuncs","_locked","fnAndPSD","shift","OpenFailed","active","transaction","durability","chromeTransactionDurability","ev","_reject","onabort","on","oncomplete","_resolve","storagemutated","bWriteLock","ReadOnly","_root","waitFor","promiseLike","_waitingFor","_waitingQueue","objectStore","spin","_spinCount","currentWaitPromise","abort","memoizedTables","_memoizedTables","transactionBoundTable","createTransactionConstructor","dbschema","complete","wasActive","createIndexSpec","src","nameFromKeyPath","createTableSchema","safariMultiStoreFix","getMaxKey","IdbKeyRange","only","getKeyExtractor","getSinglePathKeyExtractor","arrayify","_id_counter","getKeyPathAlias","createDBCore","tmpTrans","makeIDBKeyRange","upperBound","lowerBound","hasGetAll","tables","objectStoreNames","autoIncrement","indexByKeyPath","isPrimaryKey","indexNames","multiEntry","extractSchema","isAddOrPut","req","reqs","errorHandler","args1","args2","keyCount","callbackCount","successHandler","_pos","request","nonInfinitLimit","source","idbKeyRange","getAll","getAllKeys","openKeyCursor","___id","_cursorContinue","_cursorContinuePrimaryKey","continuePrimaryKey","_cursorAdvance","doThrowCursorIsStopped","gotOne","iterationPromise","resolveIteration","rejectIteration","guardedCallback","createDbCoreTable","tableMap","MIN_KEY","MAX_KEY","createMiddlewareStack","stackImpl","middlewares","down","createMiddlewareStacks","dbcore","generateMiddlewareStacks","_novip","_middlewares","tbl","setApiOnPlace","objs","tableNames","propDesc","enumerable","removeTablesApi","lowerVersionFirst","_cfg","version","runUpgraders","oldVersion","idbUpgradeTrans","globalSchema","_storeNames","rejectTransaction","createTable","populate","updateTablesAndIndexes","queue","versions","_versions","buildGlobalSchema","anyContentUpgraderHasRun","oldSchema","newSchema","adjustToExistingIndexNames","diff","getSchemaDiff","tuple","change","recreate","Upgrade","addIndex","deleteIndex","del","idxName","contentUpgrade","upgradeSchema","contentUpgradeIsAsync","returnValue","promiseFollowed","decrementor","deleteRemovedTables","runQueue","createMissingTables","oldDef","newDef","def","oldIndexes","newIndexes","oldIdx","newIdx","createObjectStore","contains","storeName","deleteObjectStore","createIndex","j","idbindex","readGlobalSchema","verno","verifyInstalledSchema","ch","_hasGetAll","dexieName","indexSpec","WorkerGlobalScope","parseIndexSyntax","primKeyAndIndexes","indexNum","trim","replace","Version","_parseStoresSpec","stores","outSchema","storesSource","storesSpec","upgrade","upgradeFunction","createVersionConstructor","versionNumber","getDbNamesTable","dbNamesDB","Dexie$1","addons","dbnames","hasDatabasesNative","databases","getDatabaseNames","infos","_onDatabaseCreated","_onDatabaseDeleted","vip","idbReady","intervalId","userAgentData","tryIdb","setInterval","clearInterval","dexieOpen","state","openCanceller","throwIfCancelled","resolveDbReady","dbReadyResolve","upgradeTransaction","wasCreated","dbName","autoSchema","round","onblocked","_fireOnBlocked","onupgradeneeded","allowEmptyDB","close","delreq","deleteDatabase","NoSuchDatabase","oldVer","pow","onversionchange","vcFired","onclose","onReadyBeingFired","fireRemainders","remainders","_close","awaitIterator","callNext","onSuccess","step","onError","throw","getNext","extractTransactionArgs","_tableArgs_","scopeFunc","enterTransactionScope","parentTransaction","scopeFuncIsAsync","PrematureCommit","pad","createVirtualIndexMiddleware","indexLookup","allVirtualIndexes","addVirtualIndexes","keyTail","lowLevelIndex","keyPathAlias","indexList","keyLength","isVirtual","virtualIndex","translateRequest","virtualCursor","createVirtualCursor","virtualIndexMiddleware","level","getObjectDiff","prfx","ap","bp","apTypeName","getEffectiveKeys","hooksMiddleware","downCore","downTable","tableMiddleware","dxTrans","addPutOrDelete","deleteNextChunk","deleteRange","getExistingValues","existingValues","contexts","existingValue","generatedPrimaryKey","objectDiff","additionalChanges","requestedValue","effectiveKeys","getFromTransactionCache","cacheExistingValuesMiddleware","cachedResult","isEmptyRange","RangeSet","fromOrTree","to","addRange","left","right","rebalance","rightWasCutOff","mergeRanges","newSet","_addRangeSet","rangesOverlap","rangeSet1","rangeSet2","i1","getRangeSetIterator","nextResult1","i2","nextResult2","keyProvided","up","_b","rootClone","oldRootRight","computeDepth","rangeSet","addKey","addKeys","observabilityMiddleware","FULL_RANGE","tableClone","mutatedParts","getRangeSet","part","pkRangeSet","delsRangeSet","newObjs","oldCache","oldObjs","trackAffectedIndexes","getRange","readSubscribers","method","subscr","queriedIndex","queriedRanges","keysPromise","resultingKeys","pKeys","wantValues","pkey","addKeyOrKeys","oldKey","newKey","deps","dependencies","cancelOpen","bSticky","newVersion","use","addon","versionInstance","_whenReady","unuse","mw","hasArguments","doDelete","backendDB","isOpen","hasBeenClosed","hasFailed","dynamicallyOpened","_transaction","onlyIfCompatible","idbMode","SubTransaction","enterTransaction","InvalidTable","symbolObservable","observable","Observable","_subscribe","extendObservabilitySet","liveQuery","querier","observer","closed","accumMuts","currentObs","subscription","mutationListener","querying","startedListening","shouldNotify","doQuery","exec","execute","domDeps","mozIndexedDB","webkitIndexedDB","msIndexedDB","webkitIDBKeyRange","Dexie","propagateLocally","updateParts","wasMe","propagatingLocally","databaseName","exists","ignoreTransaction","async","generatorFn","spawn","currentTransaction","promiseOrFunction","optionalTimeout","semVer","maxKey","updatedParts","initCustomEvent","BroadcastChannel","bc","changedParts","postMessage","onmessage","localStorage","setItem","trig","random","matchAll","includeUncontrolled","client","parse","newValue","swContainer","serviceWorker","propagateMessageLocally","getJSON","blob","plays","files","queryResult","loadFiles","file","play","ts","runQuery","eval","app","App","body"],"mappings":"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"}